-- [[ меняй эти настройки для оптимизации ]]
getgenv().Optimization = {
    state = true, -- вкл/выкл
    hide_screen = true, -- выключает прорисовку графики, бустит жесточайше фпс (вкл/выкл)
    fps = 3
};

-- Настройка серверхопа каждые 15 секунд
getgenv().ServerHopSettings = {
    interval = 15, -- 15 секунд вместо 2 минут
    last_hop_time = os.time() - math.random(0, 15), -- рандомное начальное время для рассинхронизации
    use_random_offset = true, -- использовать ли рандомную задержку перед хопом
    min_players = 2, -- минимальное количество игроков в сервере для перехода
    max_players = 10, -- максимальное количество игроков в сервере для перехода
    server_distribution = true -- распределять аккаунты по разным серверам
};

-- Настройки кеширования рифтов
getgenv().CacheSettings = {
    global_cache_file = "global_rifts_cache.json", -- файл для глобального кеша
    local_cache_file = "local_rifts_cache.json", -- файл для локального кеша
    cache_ttl = 900, -- время жизни кеша в секундах (15 минут)
    precision = 1, -- точность координат (количество знаков после запятой)
    use_shared_cache = true -- использовать общий кеш между аккаунтами
};

if getgenv().Optimization.state then
    if setfpscap ~= nil then setfpscap(getgenv().Optimization.fps); end
    UserSettings().GameSettings.MasterVolume = 0;
    settings().Rendering.QualityLevel = "Level01";
    game:GetService("RunService"):Set3dRenderingEnabled(not getgenv().Optimization.hide_screen);
end

local players = game:GetService("Players");
local local_player = players.LocalPlayer;
local http_service = game:GetService("HttpService");

-- Создаем глобальный объект для межаккаунтного кеширования
if not _G.RiftFinderCache then
    _G.RiftFinderCache = {
        rifts = {},
        last_cleanup = os.time()
    }
end

-- Исправление: добавляю ожидание и проверки на nil
local rifts
local function getRifts()
    local rendered = workspace:FindFirstChild("Rendered")
    if rendered then
        rifts = rendered:FindFirstChild("Rifts")
    end
    return rifts ~= nil
end

-- Пробуем найти рифты с задержкой
repeat
    task.wait(2) -- Ожидание для загрузки необходимых компонентов
    print("Waiting for Rifts to load...")
until getRifts()

-- Система для предотвращения дублирования вебхуков
local local_cache_file = getgenv().CacheSettings.local_cache_file
local global_cache_file = getgenv().CacheSettings.global_cache_file
local local_rifts_cache = {}
local global_rifts_cache = {}

-- Функция для создания более точного ID рифта
local function createRiftId(rift_name, position, time_expires, luck_value)
    local precision = getgenv().CacheSettings.precision
    local rounded_x = math.floor(position.X * (10^precision)) / (10^precision)
    local rounded_y = math.floor(position.Y * (10^precision)) / (10^precision)
    local rounded_z = math.floor(position.Z * (10^precision)) / (10^precision)
    
    -- Добавляем информацию о времени окончания, округляя до минуты
    local expiry_minute = math.floor(time_expires / 60) * 60
    
    return string.format("%s_%.1f_%.1f_%.1f_%d_%s", 
        rift_name, 
        rounded_x, 
        rounded_y, 
        rounded_z, 
        expiry_minute,
        luck_value or "noluck"
    )
end

-- Функция для безопасного чтения файла с обработкой ошибок
local function safeReadFile(filepath)
    if not isfile(filepath) then
        return nil
    end
    
    local success, content = pcall(function()
        return readfile(filepath)
    end)
    
    if success then
        local parsed_success, data = pcall(function()
            return http_service:JSONDecode(content)
        end)
        
        if parsed_success then
            return data
        end
    end
    
    return nil
end

-- Функция для безопасной записи файла
local function safeWriteFile(filepath, data)
    local success, encoded = pcall(function()
        return http_service:JSONEncode(data)
    end)
    
    if success then
        pcall(function()
            writefile(filepath, encoded)
        end)
        return true
    end
    
    return false
end

-- Функция для очистки кеша
local function cleanCache()
    local current_time = os.time()
    local ttl = getgenv().CacheSettings.cache_ttl
    
    -- Очищаем локальный кеш
    local new_local_cache = {}
    for rift_id, timestamp in pairs(local_rifts_cache) do
        if current_time - timestamp < ttl then
            new_local_cache[rift_id] = timestamp
        end
    end
    local_rifts_cache = new_local_cache
    
    -- Очищаем глобальный кеш
    local new_global_cache = {}
    for rift_id, timestamp in pairs(global_rifts_cache) do
        if current_time - timestamp < ttl then
            new_global_cache[rift_id] = timestamp
        end
    end
    global_rifts_cache = new_global_cache
    
    -- Очищаем глобальный объект
    if _G.RiftFinderCache then
        local new_shared_cache = {}
        for rift_id, timestamp in pairs(_G.RiftFinderCache.rifts) do
            if current_time - timestamp < ttl then
                new_shared_cache[rift_id] = timestamp
            end
        end
        _G.RiftFinderCache.rifts = new_shared_cache
        _G.RiftFinderCache.last_cleanup = current_time
    end
    
    -- Сохраняем обновленные кеши
    safeWriteFile(local_cache_file, local_rifts_cache)
    
    if getgenv().CacheSettings.use_shared_cache then
        safeWriteFile(global_cache_file, global_rifts_cache)
    end
    
    local local_count = 0
    for _ in pairs(local_rifts_cache) do local_count = local_count + 1 end
    
    local global_count = 0
    for _ in pairs(global_rifts_cache) do global_count = global_count + 1 end
    
    print("Cache cleaned: Local cache size:", local_count, "Global cache size:", global_count)
end

-- Загружаем локальный кеш
local loaded_local = safeReadFile(local_cache_file)
if loaded_local then
    local_rifts_cache = loaded_local
end

-- Загружаем глобальный кеш
if getgenv().CacheSettings.use_shared_cache then
    local loaded_global = safeReadFile(global_cache_file)
    if loaded_global then
        global_rifts_cache = loaded_global
    end
end

-- Функция проверки рифта в кеше
local function isRiftCached(rift_id)
    -- Проверяем локальный кеш
    if local_rifts_cache[rift_id] then
        return true
    end
    
    -- Проверяем глобальный файловый кеш
    if getgenv().CacheSettings.use_shared_cache and global_rifts_cache[rift_id] then
        return true
    end
    
    -- Проверяем _G объект для межаккаунтного кеширования
    if _G.RiftFinderCache and _G.RiftFinderCache.rifts[rift_id] then
        return true
    end
    
    return false
end

-- Функция для кеширования рифта
local function cacheRift(rift_id)
    local current_time = os.time()
    
    -- Сохраняем в локальный кеш
    local_rifts_cache[rift_id] = current_time
    
    -- Сохраняем в глобальный файловый кеш
    if getgenv().CacheSettings.use_shared_cache then
        global_rifts_cache[rift_id] = current_time
        safeWriteFile(global_cache_file, global_rifts_cache)
    end
    
    -- Сохраняем в _G для межаккаунтного кеширования
    if _G.RiftFinderCache then
        _G.RiftFinderCache.rifts[rift_id] = current_time
    end
    
    -- Сохраняем локальный кеш
    safeWriteFile(local_cache_file, local_rifts_cache)
    
    -- Автоматическая очистка глобального кеша если прошло достаточно времени
    if _G.RiftFinderCache and current_time - _G.RiftFinderCache.last_cleanup > 300 then
        cleanCache()
    end
end

-- Запускаем автоматическую очистку кеша каждые 5 минут
task.spawn(function()
    while true do
        task.wait(300) -- 5 минут
        print("Scheduled cache cleanup...")
        cleanCache()
    end
end)

local whitelisted_eggs = { -- теперь тут меняешь вебхуки НА КАЖДОЕ ЯЙЦО/СУНДУК, в luck через запятую в кавычках прописываешь множитель удачи
    ["rainbow-egg"] = {
        webhook = "https://discord.com/api/webhooks/1372211950334906499/_fEmj8oGQ8x4v2kUYeweBlpGdoaCoJ6tIs59BfsBUBeApzBax76neHeWmYbxZyDAXU5f",
        role_id = "", -- ID роли как строка
        luck = { "x25" },
        name = "Rainbow Egg"
    },
    ["nightmare-egg"] = {
        webhook = "https://discord.com/api/webhooks/1372212037693866014/agJ1yjXiLDXZAuiJISTd4kr3cCuCRsXuxRVmx42YqrIXJ9qpUSe7wpM9U3-MTYblwQsk",
        role_id = "",
        luck = { "x25" },
        name = "Nightmare Egg"
    },
    ["void-egg"] = {
        webhook = "https://discord.com/api/webhooks/1372211864133701642/nn8YJOJs5BleUhifO-hA0UNI3nIqnzBlHrhFSTOiibxQBGBjjvMTL8bY9jTciCbjUlNL",
        role_id = "",
        luck = { "x25" },
        name = "Void Egg"
    },
    ["royal-chest"] = {
        webhook = "https://discord.com/api/webhooks/1372212119629463753/oVq84wDoSWkyoraVjkYsdsxTBRx1bL3Ui1vUv8eAN7FJNb0Fil27LCOEF5BUT-ZP4Fx_",
        role_id = "1371539682713796648",
        name = "Royal Chest"
    },
    ["bubble-rift"] = {
        webhook = "https://discord.com/api/webhooks/1372211352357179432/7E34K-TjOiIBvKwze6XcknyeMZr73rN77eGJ1iinqCs6noRMvmNIwm3rGH4_OemmtSah",
        role_id = "",
        name = "Bubble Rifft"
    },
    ["mining-egg"] = {
        webhook = "https://discord.com/api/webhooks/1372211772303609896/PinWw2B_ppgV8JsspqCsfFEx8kbK1ozGZEywUFaO5KjTndjm3FvpE_l6V2XO3_XH_amI",
        role_id = "",
        luck = { "x25" },
        name = "Mining Egg"
    },
    ["cyber-egg"] = {
        webhook = "https://discord.com/api/webhooks/1372211676283273336/Xxiew3FwtHoGld268v6yI46y0AlS9rVlKbjDIIPWLAugNRCO-aN_G7MkXd0z9auQksud",
        role_id = "1371540351361482802",
        luck = { "x25" },
        name = "Cyber Egg"
    },
    ["dice-rift"] = {
        webhook = "https://discord.com/api/webhooks/1372211539167281244/CcP3FgYKV-sZAMmtrtu4z5J5wJJ-SCGUAfavJSvyOc-L4uciHxvIiVmsnCMnpUabrb2s",
        role_id = "1371539732022169601",
        name = "Dice Rift"
    },
    ["underworld-1"] = {
        webhook = "https://discord.com/api/webhooks/1371074619645235243/u_0v1rptBiojPUlQSSwaA7zoIbryx-4qEK1JZaaJkKd82T9Mo4VWMN3hyD6beszMNcYY",
        role_id = "1371510979116007545",
        luck = { "x25" },
        name = "Underworld 1"
    },
    ["underworld-2"] = {
        webhook = "https://discord.com/api/webhooks/1371074619645235243/u_0v1rptBiojPUlQSSwaA7zoIbryx-4qEK1JZaaJkKd82T9Mo4VWMN3hyD6beszMNcYY",
        role_id = "1371510979116007545",
        luck = { "x25" },
        name = "Underworld 2"
    },
    ["underworld-3"] = {
        webhook = "https://discord.com/api/webhooks/1371074619645235243/u_0v1rptBiojPUlQSSwaA7zoIbryx-4qEK1JZaaJkKd82T9Mo4VWMN3hyD6beszMNcYY",
        role_id = "1371510979116007545",
        luck = { "x25" },
        name = "Underworld 3"
    }
};
local spam_messages = {
    "Best Rift Finder = ģģ/ easyrift 🔥",
    "Underworld Egg is found! ģģ/ easyrift 🔥",
    "Best Pet Shop = ģģ/ easyrift 🔥",
    "REACH THE LEADERBOARDS USING ğğ/ easyrift 🏆",
    "SECRETS GIVE-AWAY HAPPENING ģģ/ easyrift 🌟",
    "X25 LUCK RIFTS AT ģģ/ easyrift 🍀",
    "UNDERWORLD RIFT ģģ/ easyrift 🥚"
};

local join_link = string.format('https://www.roblox.com/games/start?placeId=16302670534&launchData=%d/%s', game.PlaceId, game.JobId);

local parse_time = function(text)
    text = string.lower(string.gsub(text, "^%s*(.-)%s*$", "%1"));
    local number, unit = string.match(text, "(%d+)%s*(%a+)");
    if number == nil or unit == nil then 
        return 0;
    end
    
    number = tonumber(number);
    
    if string.find(unit, "second") then
        return number;
    elseif string.find(unit, "minute") then
        return number * 60;
    elseif string.find(unit, "hour") then
        return number * 3600;
    else
        return 0;
    end
end

local time_to_discorddate = function(time_)
    return string.format("<t:%d:R>", time_);
end

local request = (syn ~= nil and syn.request) or (http ~= nil and http.request) or (fluxus ~= nil and fluxus.request) or http_request or request;

-- Улучшенная функция notify для отладки пингов
local notify = function(webhook, data)
    local response = request({
        Url = webhook, 
        Body = http_service:JSONEncode(data), 
        Method = "POST", 
        Headers = { ['content-type'] = "application/json" }
    });
    print("Discord webhook response:", response.StatusCode, response.StatusMessage);
    return response;
end

-- Функция для выбора оптимального сервера на основе ID игрока
local function getPreferredServerIndex(servers)
    -- Создаем более уникальное распределение на основе ID игрока
    local playerIdMod = local_player.UserId % 100
    local timeComponent = os.time() % 60
    local preferredIndex = (playerIdMod + timeComponent) % #servers
    if preferredIndex == 0 then preferredIndex = 1 end
    return preferredIndex
end

-- Улучшенный сервер-хоп для предотвращения попадания на одни и те же серверы
local serverhop = function()
    -- Добавляем случайную задержку для рассинхронизации аккаунтов
    if getgenv().ServerHopSettings.use_random_offset then
        local random_delay = math.random(1, 3) -- Уменьшено с 3-15 до 1-3 секунд для быстрого хопа
        print("Adding random delay before server hop:", random_delay, "seconds")
        wait(random_delay)
    end
    
    -- Обновляем время последнего серверхопа
    getgenv().ServerHopSettings.last_hop_time = os.time()
    print("Initiating server hop at:", os.date("%H:%M:%S", getgenv().ServerHopSettings.last_hop_time))

    local file = "serverhop_history.json";
    local history = {};
    local current_time = os.time();
    
    -- Load history if file exists
    if pcall(function() readfile(file) end) then
        history = http_service:JSONDecode(readfile(file))
        
        -- Очищаем устаревшие записи в истории (уменьшаем с 540 до 300 секунд - 5 минут)
        local new_history = {};
        for serverId, jt in pairs(history) do
            if current_time - jt < 300 then
                new_history[serverId] = jt;
            end
        end

        history = new_history;
    end
    
    -- Добавляем жеребьевку для более случайного распределения серверов
    local page_size = 100
    -- Используем ID игрока для разнообразия страниц серверов
    local page_offset
    if getgenv().ServerHopSettings.server_distribution then
        page_offset = (local_player.UserId % 5) * page_size
    else
        page_offset = math.random(0, 3) * page_size
    end
    
    -- Используем разные sortOrder на основе ID игрока
    local sort_order = "Desc"
    if getgenv().ServerHopSettings.server_distribution and local_player.UserId % 2 == 0 then
        sort_order = "Asc"
    end
    
    local req = request({
        Url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=%s&limit=%d&cursor=%s&excludeFullGames=true", 
            game.PlaceId,
            sort_order,
            page_size,
            page_offset > 0 and tostring(page_offset) or ""
        );
    })
    
    local success, body = pcall(function()
        return http_service:JSONDecode(req.Body);
    end)
    
    if success and body and body.data then
        local servers = {};
        
        for _, server in pairs(body.data) do
            if server.playing >= getgenv().ServerHopSettings.min_players and 
               server.playing <= getgenv().ServerHopSettings.max_players and
               server.id ~= game.JobId and 
               not history[server.id] then
                
                -- Стратегия выбора сервера в зависимости от ID игрока
                local priority
                if getgenv().ServerHopSettings.server_distribution then
                    if local_player.UserId % 3 == 0 then
                        -- Предпочитаем серверы с меньшим числом игроков
                        priority = 50 - server.playing
                    elseif local_player.UserId % 3 == 1 then
                        -- Предпочитаем серверы со средним числом игроков
                        priority = 30 - math.abs(server.playing - 5)
                    else
                        -- Предпочитаем серверы с большим числом игроков
                        priority = math.min(server.playing, getgenv().ServerHopSettings.max_players)
                    end
                else
                    -- Стандартная стратегия - меньше игроков, выше приоритет
                    priority = 50 - server.playing
                end
                
                -- Добавляем сервер с учетом приоритета
                for i = 1, priority do
                    table.insert(servers, server);
                end
            end
        end
        
        -- Перемешиваем серверы для лучшей рандомизации
        for i = #servers, 2, -1 do
            local j = math.random(1, i)
            servers[i], servers[j] = servers[j], servers[i]
        end
        
        if #servers > 0 then
            -- Выбираем сервер с учетом распределения аккаунтов
            local selected_server
            
            if getgenv().ServerHopSettings.server_distribution and #servers >= 3 then
                -- Используем ID игрока для выбора сервера
                selected_server = servers[getPreferredServerIndex(servers)]
                print("Using preferred server selection based on UserId")
            else
                -- Стандартный случайный выбор
                selected_server = servers[math.random(1, #servers)]
            end
            
            history[selected_server.id] = current_time;
            writefile(file, http_service:JSONEncode(history));
            
            print("Selected server with", selected_server.playing, "players")
            game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, selected_server.id, local_player);
        else
            print("No suitable servers found, trying public teleport")
            game:GetService("TeleportService"):Teleport(game.PlaceId, local_player);
        end
    else
        print("Error fetching servers, trying public teleport")
        game:GetService("TeleportService"):Teleport(game.PlaceId, local_player);
    end
end

task.spawn(function() -- anti afk
    for _,v in pairs(getconnections(local_player.Idled)) do v:Disable() end
    for _,v in pairs(getconnections(game:GetService("UserInputService").WindowFocused)) do v:Disable() end
    for _,v in pairs(getconnections(game:GetService("UserInputService").WindowFocusReleased)) do v:Disable() end
end)

task.spawn(function()
    local channel = game:GetService("TextChatService"):WaitForChild("TextChannels"):WaitForChild("RBXGeneral");
    local time = 1;
    while task.wait() do
        channel:SendAsync(spam_messages[Random.new(tick()):NextInteger(1, #spam_messages)]);
        time += 2;
        if time > 6 then
            time = 1;
        end

        task.wait(time);
    end
end)

-- Серверхоп каждые 15 секунд
task.spawn(function()
    -- Добавляем небольшую начальную задержку, чтобы не перепрыгивать сразу
    task.wait(3)
    
    while true do
        task.wait(1) -- Проверяем каждую секунду для более точного срабатывания
        local current_time = os.time()
        local elapsed_time = current_time - getgenv().ServerHopSettings.last_hop_time
        
        if elapsed_time >= getgenv().ServerHopSettings.interval then
            print("Server hop interval reached:", elapsed_time, "seconds")
            serverhop()
        end
    end
end)

do
    local rifts_found = 0 -- счетчик найденных рифтов
    local rifts_sent = 0  -- счетчик отправленных вебхуков
    
    for _, rift in pairs(rifts:GetChildren()) do
        if not rift:IsA("Model") or not whitelisted_eggs[rift.Name] then
            continue;
        end
        
        rifts_found = rifts_found + 1
        
        local data = whitelisted_eggs[rift.Name];
        local luck = "None";
        local gui
        
        -- Исправление: добавление проверок на nil и ожидания загрузки
        local display = rift:FindFirstChild("Display")
        if display then
            gui = display:FindFirstChildOfClass("SurfaceGui")
            if data.luck ~= nil then
                if gui == nil then
                    repeat 
                        task.wait(0.5)
                        gui = display:FindFirstChildOfClass("SurfaceGui")
                    until gui ~= nil or task.wait(5) -- таймаут 5 секунд на случай, если GUI не загрузится
                end
                
                if gui and gui:FindFirstChild("Icon") and gui.Icon:FindFirstChild("Luck") then
                    if not table.find(data.luck, gui.Icon.Luck.Text) then
                        continue
                    end
                    luck = gui.Icon.Luck.Text
                else
                    continue -- Пропускаем если нет нужных компонентов
                end
            end
        else
            continue -- Пропускаем если нет Display
        end
        
        if not gui or not gui:FindFirstChild("Timer") then
            continue -- Пропускаем если нет таймера
        end

        -- Получаем время окончания рифта
        local expiry_time = os.time() + parse_time(gui.Timer.Text);
        
        -- Создаем улучшенный ID рифта с более точными координатами
        local position = rift:GetPivot().Position
        local rift_id = createRiftId(rift.Name, position, expiry_time, luck)
        
        -- Проверяем, был ли этот рифт уже найден и отправлен ранее
        if isRiftCached(rift_id) then
            print("Rift already reported:", rift_id)
            continue
        end
        
        local discord_time = time_to_discorddate(expiry_time);
        local height = math.floor(position.Y) - 4;
        local message = {
            -- Исправление формата упоминания роли - прямое использование без форматирования
            ['content'] = data.role_id and data.role_id ~= "" and ("<@&" .. data.role_id .. ">") or "",
            ['allowed_mentions'] = {
                ['parse'] = {"roles"}
            },
            ['embeds'] = {
                { 
                    ['title'] = string.format("**%s has been found!**", data.name), 
                    ['fields'] = {
                        {
                            ['name'] = "**⏲ Expires in**",
                            ['value'] = discord_time,
                            ['inline'] = true
                        },
                        {
                            ['name'] = "**📏 Height**",
                            ['value'] = string.format("`%d`", height),
                            ['inline'] = true
                        },
                        {
                            ['name'] = "**👤 Players**",
                            ['value'] = string.format("`%d`", #players:GetPlayers()),
                            ['inline'] = true
                        },
                        {
                            ['name'] = "**🍀 Luck**",
                            ['value'] = string.format("`%s`", luck)
                        }
                        -- Убираем поле Join link, так как будет кнопка
                    },
                    ['color'] = 4508791,
                    ['timestamp'] = DateTime.now():ToIsoDate(),
                    -- Добавляем футер
                    ['footer'] = {
                        ['text'] = "gg/easyrift • " .. os.date("%H:%M", os.time())
                    }
                }
            },
            -- Добавляем компоненты для кнопки
            ['components'] = {
                {
                    ['type'] = 1, -- ActionRow
                    ['components'] = {
                        {
                            ['type'] = 2, -- Button
                            ['style'] = 5, -- Link button
                            ['label'] = "Join", 
                            ['url'] = join_link
                        }
                    }
                }
            }
        };

        -- Кешируем рифт перед отправкой вебхука
        cacheRift(rift_id)
        
        -- Отправляем вебхук
        notify(data.webhook, message);
        rifts_sent = rifts_sent + 1
        
        -- Добавляем небольшую задержку между отправками вебхуков
        task.wait(0.5)
    end
    
    print("Rifts found:", rifts_found, "Webhooks sent:", rifts_sent)
    
    -- Не делаем моментальный серверхоп здесь, так как работает таймер
end

-- Добавляем принудительный серверхоп через 30 секунд после запуска, если по каким-то причинам обычный таймер не сработал
task.spawn(function()
    task.wait(30)
    if os.time() - getgenv().ServerHopSettings.last_hop_time >= 30 then
        print("Forced server hop after 30 seconds")
        serverhop()
    end
end)

game:GetService("CoreGui"):FindFirstChild("RobloxPromptGui"):FindFirstChild("promptOverlay").ChildAdded:Connect(function(child) -- при кике игрой
    serverhop();
end)
